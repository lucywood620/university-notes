\documentclass{article}[18pt]
\usepackage{../../../../format}
\lhead{Theory of Computation - Models of Computation}
\usepackage{mathrsfs}

\begin{document}
\begin{center}
\underline{\huge Advanced Topics in Computability}
\end{center}
\section{Diagonalisation}
\begin{defin}[Countable]
A set S is countable if there is a one-to-one correspondence between S and the set of natural numbers $\mathbb{N}$
\end{defin}
\section{Cantor's Proof}
\textbf{Proposition}: The set of reals in the interval (0,1) is uncountable\\
\\
\textbf{Proof}: A real number A in (0,1) is an (infinite) decimal expansion: $A=0.a_1a_2a_3...$\\
\\
Assume, for the sake of contradiction, there is a one-to-one correspondence between the real interval (0,1) and $\mathbb{N}$, i.e. all the reals in (0,1) can be ordered in a sequence
$$A_1,A_2,A_3...$$
We will construct a real number which is not in the sequence
\section{Cantor's diagonal argument}
Denote $A_i=0.a_1^ia_2^ia_3^i....$ and put the sequence in the following rectangular table
\[
\begin{array}{lllllllll}{A_{1}=} & {0} & {.} & {a_{1}^{1}} & {a_{2}^{1}} & {a_{3}^{1}} & {\ldots} & {\ldots} & {\cdots} \\
 {A_{2}=} & {0} & {\cdot} & {a_{1}^{2}} & {a_{2}^{2}} & {a_{3}^{2}} & {\ldots} & {\ldots} & {\cdots} \\
  {A_{3}=} & {0} & {\cdot} & {a_{1}^{3}} & {a_{2}^{3}} & {a_{3}^{3}} & {\ldots} & {\ldots} & {\cdots} \\
   {} & {\vdots} & {} & {} & {} & {\ddots} & {} \\
    {A_{i}=} & {0} & {.} & {a_{2}^{i}} & {a_{3}^{i}} & {\ldots} & {a_{i}^{i}} & {\cdots} & {\cdots} \\
     {\vdots} & {} & {} & {} & {} & {} & {\ddots} & {} \\
      {\vdots} & {} & {} & {} & {} & {} && {\ddots} \\
       {} & {} & {} & {} & {} &  & &&{\ddots}\end{array}
\]
Construct a new number $B=0.b_1b_2b_3...$ by taking
\[
b_{i}=\left\{\begin{array}{ll}{a_{i}^{i}+1} & {\text { if } a_{i}^{i}<9} \\ {0} & {\text { if } a_{i}^{i}=9}\end{array}\right.
\]
Now, B is a real number in (0,1) which is not in the table above, as $b_i\neq a_i^i$ for every i
\section{Halting problem by diagonalisation}
The set of all strings over a finite alphabet is countable - order them by length first and order the ones of the same length in lexicographic order
\[
\varepsilon, 0,1,00,01,10,11,000,001,010,011,100,101, \ldots
\]
Therefore, the set of all Turing machines is countable, too. Put all TMs vs all inputs in an infinite table.
\begin{center}
	\includegraphics[scale=0.7]{Halting}
\end{center}
With the help of HALT machine, we created a TM M tat everywhere disagrees with the diagonal
\section{The class of Nice machines}
A set of Turing machines $\mathscr{N}$ has a Universal machine $U_{\mathscr{N}}(i,w)$ if
\begin{enumerate}
	\item For every machines $N\in \mathscr{N}$, there is a number $n$ such that $N(w)=U_{\mathscr{N}}(n,w)$ or all inputs $w$
	\item For every number $n$, the machine $U_{\mathscr{N}}(n,.)\in \mathscr{N}$
\end{enumerate}
\begin{defin}[Nice machines]
The class of "nice" machines $\mathscr{N}$ is the set of all TMs that terminate on every input
\end{defin}
\textbf{Proposition}: The class of "nice" machines $\mathscr{N}$ does not have a universal machine\\
\\
\textbf{Proof}: Assume that there is a universal function $U_{\mathscr{N}}(i,w)$. Diagonalise: consider the machine M defined by
\[
M\left(w_{i}\right)=\neg U_{\mathscr{N}}\left(i, w_{i}\right)
\]
for all i\\
\\
M itself is a nice machine, so there much be a number $n$ such that $M(w)=U_{\mathscr{N}}(n,w)$ for all inputs $w$. In particular, for $w=w_n$ we would have that
\[
M\left(w_{n}\right)=U_{\mathscr{N}}\left(n, w_{n}\right)
\]
However, but by the construction of M we have that
\[
M\left(w_{n}\right)=\neg U_{\mathscr{N}}\left(n, w_{n}\right)
\]
which is a contradiction
\section{Self-Reference}
We want a program (Turing machine) that ignores the input and produced its own source code (description) as output.
\begin{defin}[Quine]
A program that generates a copy of its own source code as its complete output
\end{defin}
\section{Solution by mutual recursion}
A quine that consists of two parts: A followed by B. A prints out B in a straightforward way, and then B prints out A using the output that has just been produced by A.
\begin{center}
	\includegraphics[scale=0.7]{"Mutual Recursion"}
\end{center}
\section{m-reducibility}
\textbf{Definition}. Let A and B be languages over the same alphabet $\Sigma$. A is a many-to-one reducible to B (write $A\leqslant B$) if there is a Turing machine F that terminates on every input $u\in \Sigma^*$, and such that
$$A\{u\in \Sigma^*|F(u)\in B\}$$
Informally: checking $u\in A$ is no harder than checking $w\in B$
\subsection{Properties of m-reducibility}
\textbf{Proposition}. Suppose $A\leqslant B$
\begin{enumerate}
	\item If B is Turing-decidable, so is A
	\item If B is Turing-recognisable, so is A
	\item If $A\leqslant B$ and $B\leqslant C$, then $A\leqslant C$
\end{enumerate}
\textbf{Definition}. Denote $A\equiv B$ to mean that $A\leqslant B$ and $B\leqslant A$\\
\\
Informally: A and B are equally difficult
\section{m-completeness}
\textbf{Definition}. A language A is m-complete if
\begin{enumerate}
	\item A is Turing-recognisable
	\item For every Turing-recognisable language B, $B\leqslant A$
\end{enumerate}
Informally: If A is m-complete then A is as hard as any other Turing-recognisable language\\
\\
\textbf{Corollary} If A is m-complete and $A\leqslant B$, then B is m-complete\\
\\
\textbf{Definition} - The Halting language H consists of the words $\langle M \rangle \circ w$ (over some fixed alphabet) such that the Turing machine M terminates on $w$\\
\\
\textbf{Theorem} H is M complete\\
\\
\textbf{Proof}: Generic reduction. Pick any Turing-recognisable language A. It is recognised by some machine $M_A$. Reduce it to H by mapping any word $w$ onto the word $\langle M_A \rangle \circ w$. It is obvious that the reduction is computable and $w\in A$ iff $\langle M_A \rangle \circ w \in H$\\
\\
\textbf{Definition}: $H_0$ is the "diagonal" of H, i.e. the language $\langle M \rangle \circ \langle M \rangle$ such that M terminates on $\langle M \rangle$\\
\\
\textbf{Theorem}: $H_0$ is m-complete\\
\\
\textbf{Proof}: Reduction from H. Given a word $\langle M \rangle \circ w$, create a Turing machine $N_{M,w}$ that simulates M on w (and note that it ignores the input) - this can be done using a universal Turing machine. Now, $N_{M,w}$ terminates on any input iff M terminates on w. In particular $N_{M,w}$ terminates on $\langle N_{M,w}$ iff M terminates on w
\section{Oracle Turing Machine and t-reducibility}
\textbf{Definition}
\begin{enumerate}
	\item An oracle for a language A is a black-box that takes a word w as an input and instantly (and correctly) replies if $w\in A$
	\item An oracle Turing machine M, denotes by $M^A$ is a Turing machine that has an additional capability of making calls to an oracle for the language A
\end{enumerate}
\textbf{Definition}: A language A is t-reducible to a language B is A is decidable by some oracle Turing machine $M^B$\\
\\
\textbf{Theorem}: If $A\leqslant_t B$ and B is Turing-decidable, then A is Turing-decidable
\end{document}